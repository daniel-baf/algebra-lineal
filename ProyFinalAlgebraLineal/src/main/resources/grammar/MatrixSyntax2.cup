/**************************************************/
/************** SECTION 1: USER CODE **************/
/**************************************************/

package Model.Compiler;

import java_cup.runtime.*;
import java.util.ArrayList;         // array to save data
import Model.Matrix.Matrix;         // matrix to save data
import Model.Utils.CustomLogger;    // save errors in the logger
import Domain.Markov.MarkovData;    // Markov node
import Domain.AVL.NodeAVLBuilder;   // node for arith operations matrix
import Domain.AVL.NodeAVL;          // node AVL


/**************************************************/
/************ SECTION 2: USER METHODS *************/
/**************************************************/

parser code {:

    public ParserUtils parserUtils;
    public ParserController parserController;

    // constructor
    public MatrixParser(MatrixLexer lexer) {
        super(lexer);
        this.parserController = new ParserController(new ParserModel());
        this.parserUtils = ParserUtils.getInstance();
    }

    // error methods
    public void report_error(String message, Object info) {
        CustomLogger.getInstance().addLog("Error at parser with provided syntax", true);
    }
    
    public void report_fatal_error(String message, Object info) {
        CustomLogger.getInstance().addLog("Unable to recover fatal error", true);
    }

    public void syntax_error(Symbol cur_token) {
        try {
            // Get line and column information from the Symbol
            int line = cur_token.left; // Adjust to 1-indexed
            int column = cur_token.right; // Adjust to 1-indexed

            // save error to be shown
            ArrayList<String> expectedTkns = new ArrayList<>();
            expected_token_ids().forEach(symT -> {
                expectedTkns.add(sym.terminalNames[symT]);
            });
            String value = cur_token.value  != null? cur_token.value.toString(): "NA";
            CustomLogger.getInstance().addLog(String.format("SYNTAX ERROR Line(%1$d) Column(%2$d), expected tokens must be %3$s", line, column,  expectedTkns), true);

        } catch (Exception e) {
            CustomLogger.getInstance().addLog("unable to save error at matrix parser " + e.getMessage(), true);
        }
    }

    public void unrecovered_syntax_error(Symbol cur_token) {
        CustomLogger.getInstance().addLog("unrecovered sintax error", true);
    }   

    public ParserModel getParserModel() {
        return this.parserController.getModel();
    }
:}

/**************************************************/
/********** SECTION 3: SYNTAX RULES **********/
/**************************************************/

// terminal from lexer
terminal LBRACKET, RBRACKET, LPARENTHESIS, RPARENTHESIS, PLUS, TIMES, MINUS, DIVIDE, COMMA, SEMI_COLON, 
         MATRIX, ARITH, INVERSE, DETERMINANT, RANK, ENCRYPT, DECRYPT, GAUSS, JORDAN, MARKOV, 
         IDENTIFIER, NUMBER, UNKNOWN, STRING;

// non terminal
non terminal main, matrices_declaration, matrix_declaration, matrix_definition, vector_array,
    operations_declaration, operation_declaration,
    inverse_declaration, determinant_declaration, rank_declaration, encrypt_declaration, decrypt_declaration,
    gauss_declaration, gjordan_declaration, markov_declaration, arith_declaration,
    arith_expression, arith_term, arith_factor, arith_primary,
    ids_declaration, markov_ids_declaration, numbers_vector;

start with main;

main::=
        matrices_declaration operations_declaration
    |   matrices_declaration
;

// MATRIX DEF ; MATRIX NEW ... 
matrices_declaration::=
        matrix_declaration:newMatrix matrices_declaration                                  {: parserController.saveMatrix((Matrix) newMatrix); :}
    |   matrix_declaration:newMatrix                                                       {: parserController.saveMatrix((Matrix) newMatrix); :}
    |   error SEMI_COLON
;

// matrix a [...]
matrix_declaration::=
    MATRIX IDENTIFIER:id LBRACKET matrix_definition:defined_matrix RBRACKET SEMI_COLON      {: RESULT = parserUtils.configureFinalMatrix((String) id, (Matrix) defined_matrix); :}
;

// array, ... array
matrix_definition::=
        matrix_definition:child_matrix COMMA vector_array:parent_matrix                     {:  RESULT = parserUtils.concatMatrix((Matrix) child_matrix, (ArrayList<Double>) parent_matrix ); :}
    |   vector_array:parent_matrix                                                          {:  RESULT = parserUtils.generateMainMatrix((ArrayList<Double>) parent_matrix); :}
;

// num num ... num
vector_array::=
        vector_array:num_vector NUMBER:num                                                  {:  RESULT = parserUtils.concatDoublesVector((ArrayList<Double>) num_vector, Double.parseDouble((String)num));  :}
    |   NUMBER:num                                                                          {:  RESULT = parserUtils.concatDoublesVector(null,  Double.parseDouble((String)num));  :}
;

// multiple declarations
operations_declaration::=
        operation_declaration operations_declaration
    |   operation_declaration
;

operation_declaration::=
        inverse_declaration
    |   determinant_declaration
    |   rank_declaration
    |   encrypt_declaration
    |   decrypt_declaration
    |   gauss_declaration
    |   gjordan_declaration
    |   markov_declaration
    |   arith_declaration
;

inverse_declaration::=
    INVERSE ids_declaration:ids SEMI_COLON                                                  {:   parserController.saveInStringHashmap(CommonParserHashKey.INVERSE, (ArrayList<String>) ids);   :}
;

determinant_declaration::=
    DETERMINANT ids_declaration:ids SEMI_COLON                                              {:   parserController.saveInStringHashmap(CommonParserHashKey.DETERMINANT, (ArrayList<String>) ids);   :}
;

rank_declaration::=
    RANK ids_declaration:ids SEMI_COLON                                                     {:   parserController.saveInStringHashmap(CommonParserHashKey.RANK, (ArrayList<String>) ids);   :}
;

encrypt_declaration::=
    ENCRYPT STRING:string SEMI_COLON                                                        {:   ArrayList<String> tmpValues = new ArrayList<>();
                                                                                                 tmpValues.add(parserUtils.removeComillasToString((String) string));
                                                                                                 parserController.saveInStringHashmap(CommonParserHashKey.ENCRYPT, tmpValues);
                                                                                             :}
;

decrypt_declaration::=
    DECRYPT numbers_vector:numbers SEMI_COLON                                                {:   parserController.saveDecrypts((ArrayList<Double>) numbers);   :}
;

gauss_declaration::=
    GAUSS ids_declaration:ids SEMI_COLON                                                     {:   parserController.saveInStringHashmap(CommonParserHashKey.GAUSS, (ArrayList<String>) ids);   :}
;

gjordan_declaration::=
    JORDAN ids_declaration:ids SEMI_COLON                                                    {:   parserController.saveInStringHashmap(CommonParserHashKey.JORDAN, (ArrayList<String>) ids);   :}
;

markov_declaration::=
    MARKOV markov_ids_declaration:markov_nodes SEMI_COLON                                    {:   parserController.saveInStringHashmap(CommonParserHashKey.MARKOV, (ArrayList<MarkovData>) markov_nodes );  :}
;

ids_declaration::=
        IDENTIFIER:id COMMA ids_declaration:ids                                              {:   ArrayList<String> mergeIds = new ArrayList<>() {{ add((String) id); }};
                                                                                                  mergeIds.addAll((ArrayList<String>) ids);
                                                                                                  RESULT = mergeIds;
                                                                                             :}
    |   IDENTIFIER:id                                                                        {:   ArrayList<String> ids = new ArrayList<>(){{ add((String) id); }};
                                                                                                  RESULT = ids;
                                                                                             :}
;

numbers_vector::=
        NUMBER:num numbers_vector:numbers                                                    {:   ArrayList<Double> mergeNums = new ArrayList<>() {{ add(Double.parseDouble(num.toString())); }};
                                                                                                  mergeNums.addAll((ArrayList<Double>) numbers);
                                                                                                  RESULT = mergeNums;
                                                                                             :}
    |   NUMBER:num                                                                           {:   ArrayList<Double> numbers = new ArrayList<>(){{ add(Double.parseDouble(num.toString())); }};
                                                                                                  RESULT = numbers;
                                                                                             :}
;

markov_ids_declaration::=
        IDENTIFIER:matrix IDENTIFIER:status NUMBER:iterations COMMA markov_ids_declaration:markov_vector
                                                                                             {:  ArrayList<MarkovData> newData = new ArrayList<>() {{ add(new MarkovData((String) matrix, (String) status, Integer.parseInt((String) iterations))); }};
                                                                                                 newData.addAll((ArrayList<MarkovData>) markov_vector);
                                                                                                 RESULT = newData;
                                                                                             :}
    |   IDENTIFIER:matrix IDENTIFIER:status NUMBER:iterations                                {:  RESULT = new ArrayList<MarkovData>() {{ add(new MarkovData((String) matrix, (String) status, Integer.parseInt((String) iterations))); }};    :}
;

arith_declaration::=
        ARITH arith_expression:expr SEMI_COLON                                               {:   parserController.saveInStringHashmap(CommonParserHashKey.ARITH_MATRIX, new ArrayList<NodeAVL>() {{ add((NodeAVL) expr); }} );  :}
;


arith_expression::=
        arith_term:expression                                                                {:   RESULT = (NodeAVL) expression;   :}
   |    arith_expression:lchild PLUS arith_term:rchild                                       {:   NodeAVL leftChild = (NodeAVL) lchild;
                                                                                                  NodeAVL rightChild = (NodeAVL) rchild;
                                                                                                  NodeAVL parentNode = new NodeAVLBuilder<String>().setLeftChild(leftChild).setRightChild(rightChild).setData("+").build();
                                                                                                  leftChild.setParent(parentNode);
                                                                                                  rightChild.setParent(parentNode);
                                                                                                  RESULT = parentNode;
                                                                                             :}
   |    arith_expression:lchild MINUS arith_term:rchild                                      {:   NodeAVL leftChild = (NodeAVL) lchild;
                                                                                                  NodeAVL rightChild = (NodeAVL) rchild;
                                                                                                  NodeAVL parentNode = new NodeAVLBuilder<String>().setLeftChild(leftChild).setRightChild(rightChild).setData("-").build();
                                                                                                  leftChild.setParent(parentNode);
                                                                                                  rightChild.setParent(parentNode);
                                                                                                  RESULT = parentNode;
                                                                                             :}
;

arith_term ::=
        arith_factor
   |    arith_term:lchild TIMES arith_factor:rchild                                          {:    NodeAVL leftChild = (NodeAVL) lchild;
                                                                                                   NodeAVL rightChild = (NodeAVL) rchild;
                                                                                                   NodeAVL parentNode = new NodeAVLBuilder<String>().setLeftChild(leftChild).setRightChild(rightChild).setData("*").build();
                                                                                                   leftChild.setParent(parentNode);
                                                                                                   rightChild.setParent(parentNode);
                                                                                                   RESULT = parentNode;
                                                                                             :}
   |    arith_term:lchild DIVIDE arith_factor:rchild                                         {:   NodeAVL leftChild = (NodeAVL) lchild;
                                                                                                  NodeAVL rightChild = (NodeAVL) rchild;
                                                                                                  NodeAVL parentNode = new NodeAVLBuilder<String>().setLeftChild(leftChild).setRightChild(rightChild).setData("/").build();
                                                                                                  leftChild.setParent(parentNode);
                                                                                                  rightChild.setParent(parentNode);
                                                                                                  RESULT = parentNode;
                                                                                             :}
;

arith_factor ::=
    arith_primary:expression                                                                 {:   RESULT = expression; :}
  | LPARENTHESIS arith_expression:expression RPARENTHESIS                                    {:   NodeAVL childNode = (NodeAVL) expression;
                                                                                                  NodeAVL parentNode = new NodeAVLBuilder<String>().setLeftChild(childNode).setData("()").build();
                                                                                                  childNode.setParent(parentNode);
                                                                                                  RESULT = parentNode;
                                                                                             :}
;

arith_primary ::=
            NUMBER:num                                                                       {:   RESULT = new NodeAVLBuilder<Double>().setData(Double.parseDouble((String) num)).build(); :}
          | IDENTIFIER:id                                                                    {:   RESULT = new NodeAVLBuilder<String>().setData((String) id).build();   :}
;
