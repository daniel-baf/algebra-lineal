/**************************************************/
/************** SECTION 1: USER CODE **************/
/**************************************************/

package Model.Compiler;

import java_cup.runtime.*;
import java.util.ArrayList; // array to save data
import Model.Matrix.Matrix; // matrix to save data
import Model.Utils.CustomLogger; // save errors in the logger
import Model.Compiler.ParserUtils; // utils to manage parser reader

/**************************************************/
/************ SECTION 2: USER METHODS *************/
/**************************************************/

parser code {:

    public ArrayList<Matrix> matrices;
    public ParserUtils parserUtils;

    // constructor
    public MatrixParser(MatrixLexer lexer) {
        super(lexer);
        this.matrices = new ArrayList<>();
        this.parserUtils = ParserUtils.getInstance();
    }

    // error methods
    public void report_error(String message, Object info) {
        CustomLogger.getInstance().addLog("Error at parser with provided syntax", true);
    }
    
    public void report_fatal_error(String message, Object info) {
        CustomLogger.getInstance().addLog("Unable to recover fatal error", true);
    }

    public void syntax_error(Symbol cur_token) {
        try {
            // Get line and column information from the Symbol
            int line = cur_token.left; // Adjust to 1-indexed
            int column = cur_token.right; // Adjust to 1-indexed

            // save error to be shown
            ArrayList<String> expectedTkns = new ArrayList<>();
            expected_token_ids().forEach(symT -> {
                expectedTkns.add(sym.terminalNames[symT]);
            });
            String value = cur_token.value  != null? cur_token.value.toString(): "NA";
            CustomLogger.getInstance().addLog(String.format("SYNTAX ERROR Line(%1$d) Column(%2$d), expected tokens must be %3$s", line, column,  expectedTkns), true);

        } catch (Exception e) {
            CustomLogger.getInstance().addLog("unable to save error at matrix parser " + e.getMessage(), true);
        }
    }

    public void unrecovered_syntax_error(Symbol cur_token) {
        CustomLogger.getInstance().addLog("unrecovered sintax error", true);
    }   

    public ArrayList<Matrix> getMatrices() {
        return this.matrices;
    }
:}

/**************************************************/
/********** SECTION 3: SYNTAX RULES **********/
/**************************************************/

// terminal from lexer
terminal LBRACKET, RBRACKET, LPARENTHESIS, RPARENTHESIS, PLUS, TIMES, MINUS, DIVIDE, COMMA, SEMI_COLON, 
         MATRIX, ARITH, INVERSE, DETERMINANT, RANK, ENCRYPT, DECRYPT, GAUSS, JORDAN, MARKOV, 
         IDENTIFIER, NUMBER, UNKNOWN, STRING;

// non terminal
non terminal main, matrices_declaration, matrix_declaration, matrix_definition, vector_array,
    operations_declaration, operation_declaration,
    inverse_declaration, determinant_declaration, rank_declaration, encrypt_declaration, decrypt_declaration,
    gauss_declaration, gjordan_declaration, markov_declaration, arith_declaration,
    arith_expression, arith_term, arith_factor, arith_primary,
    ids_declaration, markov_ids_declaration, numbers_vector;

start with main;

main::=
        matrices_declaration operations_declaration
    |   matrices_declaration
;

// MATRIX DEF ; MATRIX NEW ... 
matrices_declaration::=
        matrix_declaration:newMatrix matrices_declaration                                  {: matrices.add((Matrix) newMatrix); :}
    |   matrix_declaration:newMatrix                                                       {: matrices.add((Matrix) newMatrix); :}
    |   error SEMI_COLON
;

// matrix a [...]
matrix_declaration::=
    MATRIX IDENTIFIER:id LBRACKET matrix_definition:defined_matrix RBRACKET SEMI_COLON      {: RESULT = parserUtils.configureFinalMatrix((String) id, (Matrix) defined_matrix); :}
;

// array, ... array
matrix_definition::=
        matrix_definition:child_matrix COMMA vector_array:parent_matrix                     {:  RESULT = parserUtils.concatMatrix((Matrix) child_matrix, (ArrayList<Double>) parent_matrix ); :}
    |   vector_array:parent_matrix                                                          {:  RESULT = parserUtils.generateMainMatrix((ArrayList<Double>) parent_matrix); :}
;

// num num ... num
vector_array::=
        vector_array:num_vector NUMBER:num                                                  {:  RESULT = parserUtils.concatDoublesVector((ArrayList<Double>) num_vector, Double.parseDouble((String)num));  :}
    |   NUMBER:num                                                                          {:  RESULT = parserUtils.concatDoublesVector(null,  Double.parseDouble((String)num));  :}
;

// multiple declarations
operations_declaration::=
        operation_declaration operations_declaration
    |   operation_declaration
;

operation_declaration::=
        inverse_declaration
    |   determinant_declaration
    |   rank_declaration
    |   encrypt_declaration
    |   decrypt_declaration
    |   gauss_declaration
    |   gjordan_declaration
    |   markov_declaration
    |   arith_declaration
;

inverse_declaration::=
    INVERSE ids_declaration SEMI_COLON
;

determinant_declaration::=
    DETERMINANT ids_declaration SEMI_COLON
;

rank_declaration::=
    RANK ids_declaration SEMI_COLON
;

encrypt_declaration::=
    ENCRYPT STRING SEMI_COLON
;

decrypt_declaration::=
    DECRYPT numbers_vector SEMI_COLON
;

gauss_declaration::=
    GAUSS ids_declaration SEMI_COLON
;

gjordan_declaration::=
    JORDAN ids_declaration SEMI_COLON
;

markov_declaration::=
    MARKOV markov_ids_declaration SEMI_COLON
;

ids_declaration::=
        IDENTIFIER COMMA ids_declaration
    |   IDENTIFIER
;

numbers_vector::=
        NUMBER numbers_vector
    |   NUMBER
;

markov_ids_declaration::=
        IDENTIFIER NUMBER COMMA markov_ids_declaration
    |   IDENTIFIER NUMBER
;

arith_declaration::=
        ARITH arith_expression SEMI_COLON
;


arith_expression::=
        arith_term
   |    arith_expression PLUS arith_term
   |    arith_expression MINUS arith_term
;

arith_term ::=
        arith_factor
   |    arith_term TIMES arith_factor
   |    arith_term DIVIDE arith_factor
;

arith_factor ::=
    arith_primary
  | LPARENTHESIS arith_expression RPARENTHESIS
;

arith_primary ::=
            NUMBER
          | IDENTIFIER
;
