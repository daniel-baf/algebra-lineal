/**************************************************/
/************** SECTION 1: USER CODE **************/
/**************************************************/

package Model.Compiler;

import java_cup.runtime.*;
import java.util.ArrayList; // array to save data
import Model.Matrix.Matrix; // matrix to save data
import Model.Utils.CustomLogger; // save errors in the logger

/**************************************************/
/************ SECTION 2: USER METHODS *************/
/**************************************************/

parser code {:

    public ParserUtils parserUtils;
    public ParserController parserController;

    // constructor
    public MatrixParser(MatrixLexer lexer) {
        super(lexer);
        this.parserController = new ParserController(new ParserModel());
        this.parserUtils = ParserUtils.getInstance();
    }

    // error methods
    public void report_error(String message, Object info) {
        CustomLogger.getInstance().addLog("Error at parser with provided syntax", true);
    }
    
    public void report_fatal_error(String message, Object info) {
        CustomLogger.getInstance().addLog("Unable to recover fatal error", true);
    }

    public void syntax_error(Symbol cur_token) {
        try {
            // Get line and column information from the Symbol
            int line = cur_token.left; // Adjust to 1-indexed
            int column = cur_token.right; // Adjust to 1-indexed

            // save error to be shown
            ArrayList<String> expectedTkns = new ArrayList<>();
            expected_token_ids().forEach(symT -> {
                expectedTkns.add(sym.terminalNames[symT]);
            });
            String value = cur_token.value  != null? cur_token.value.toString(): "NA";
            CustomLogger.getInstance().addLog(String.format("SYNTAX ERROR Line(%1$d) Column(%2$d), expected tokens must be %3$s", line, column,  expectedTkns), true);

        } catch (Exception e) {
            CustomLogger.getInstance().addLog("unable to save error at matrix parser " + e.getMessage(), true);
        }
    }

    public void unrecovered_syntax_error(Symbol cur_token) {
        CustomLogger.getInstance().addLog("unrecovered sintax error", true);
    }   

    public ParserModel getParserModel() {
        return this.parserController.getModel();
    }
:}

/**************************************************/
/********** SECTION 3: SYNTAX RULES **********/
/**************************************************/

// terminal from lexer
terminal LBRACKET, RBRACKET, LPARENTHESIS, RPARENTHESIS, PLUS, TIMES, MINUS, DIVIDE, COMMA, SEMI_COLON, 
         MATRIX, ARITH, INVERSE, DETERMINANT, RANK, ENCRYPT, DECRYPT, GAUSS, JORDAN, MARKOV, 
         IDENTIFIER, NUMBER, UNKNOWN, STRING;

// non terminal
non terminal main, matrices_declaration, matrix_declaration, matrix_definition, vector_array,
    operations_declaration, operation_declaration,
    inverse_declaration, determinant_declaration, rank_declaration, encrypt_declaration, decrypt_declaration,
    gauss_declaration, gjordan_declaration, markov_declaration, arith_declaration,
    arith_expression, arith_term, arith_factor, arith_primary,
    ids_declaration, markov_ids_declaration, numbers_vector;

start with main;

main::=
        matrices_declaration operations_declaration
    |   matrices_declaration
;

// MATRIX DEF ; MATRIX NEW ... 
matrices_declaration::=
        matrix_declaration:newMatrix matrices_declaration                                  {: parserController.saveMatrix((Matrix) newMatrix); :}
    |   matrix_declaration:newMatrix                                                       {: parserController.saveMatrix((Matrix) newMatrix); :}
    |   error SEMI_COLON
;

// matrix a [...]
matrix_declaration::=
    MATRIX IDENTIFIER:id LBRACKET matrix_definition:defined_matrix RBRACKET SEMI_COLON      {: RESULT = parserUtils.configureFinalMatrix((String) id, (Matrix) defined_matrix); :}
;

// array, ... array
matrix_definition::=
        matrix_definition:child_matrix COMMA vector_array:parent_matrix                     {:  RESULT = parserUtils.concatMatrix((Matrix) child_matrix, (ArrayList<Double>) parent_matrix ); :}
    |   vector_array:parent_matrix                                                          {:  RESULT = parserUtils.generateMainMatrix((ArrayList<Double>) parent_matrix); :}
;

// num num ... num
vector_array::=
        vector_array:num_vector NUMBER:num                                                  {:  RESULT = parserUtils.concatDoublesVector((ArrayList<Double>) num_vector, Double.parseDouble((String)num));  :}
    |   NUMBER:num                                                                          {:  RESULT = parserUtils.concatDoublesVector(null,  Double.parseDouble((String)num));  :}
;

// multiple declarations
operations_declaration::=
        operation_declaration operations_declaration
    |   operation_declaration
;

operation_declaration::=
        inverse_declaration
    |   determinant_declaration
    |   rank_declaration
    |   encrypt_declaration
    |   decrypt_declaration
    |   gauss_declaration
    |   gjordan_declaration
    |   markov_declaration
    |   arith_declaration
;

inverse_declaration::=
    INVERSE ids_declaration:ids SEMI_COLON                                                  {:   parserController.saveInStringHashmap(CommonParserHashKey.INVERSE, (ArrayList<String>) ids);   :}
;

determinant_declaration::=
    DETERMINANT ids_declaration:ids SEMI_COLON                                              {:   parserController.saveInStringHashmap(CommonParserHashKey.DETERMINANT, (ArrayList<String>) ids);   :}
;

rank_declaration::=
    RANK ids_declaration:ids SEMI_COLON                                                     {:   parserController.saveInStringHashmap(CommonParserHashKey.RANK, (ArrayList<String>) ids);   :}
;

encrypt_declaration::=
    ENCRYPT STRING:string SEMI_COLON                                                        {:   ArrayList<String> tmpValues = new ArrayList<>();
                                                                                                 tmpValues.add(parserUtils.removeComillasToString((String) string));
                                                                                                 parserController.saveInStringHashmap(CommonParserHashKey.ENCRYPT, tmpValues);
                                                                                             :}
;

decrypt_declaration::=
    DECRYPT numbers_vector SEMI_COLON
;

gauss_declaration::=
    GAUSS ids_declaration SEMI_COLON
;

gjordan_declaration::=
    JORDAN ids_declaration SEMI_COLON
;

markov_declaration::=
    MARKOV markov_ids_declaration SEMI_COLON
;

ids_declaration::=
        IDENTIFIER:id COMMA ids_declaration:ids                                            {:   ArrayList<String> mergeIds = new ArrayList<>();
                                                                                                mergeIds.add((String) id);
                                                                                                mergeIds.addAll((ArrayList<String>) ids);
                                                                                                RESULT = mergeIds;
                                                                                           :}
    |   IDENTIFIER:id                                                                      {:   ArrayList<String> ids = new ArrayList<>();
                                                                                                ids.add((String) id);
                                                                                                RESULT = ids;
                                                                                            :}
;

numbers_vector::=
        NUMBER:num numbers_vector:numbers                                                   {:   ArrayList<Double> mergeNums = new ArrayList<>();
                                                                                                 mergeNums.add(Double.parseDouble(num.toString()));
                                                                                                 mergeNums.addAll((ArrayList<Double>) numbers);
                                                                                                 RESULT = mergeNums;
                                                                                            :}
    |   NUMBER:num                                                                          {:   ArrayList<Double> numbers = new ArrayList<>();
                                                                                                 numbers.add(Double.parseDouble(num.toString()));
                                                                                                 RESULT = numbers;
                                                                                             :}
;

markov_ids_declaration::=
        IDENTIFIER IDENTIFIER NUMBER COMMA markov_ids_declaration
    |   IDENTIFIER IDENTIFIER NUMBER
;

arith_declaration::=
        ARITH arith_expression SEMI_COLON
;


arith_expression::=
        arith_term
   |    arith_expression PLUS arith_term
   |    arith_expression MINUS arith_term
;

arith_term ::=
        arith_factor
   |    arith_term TIMES arith_factor
   |    arith_term DIVIDE arith_factor
;

arith_factor ::=
    arith_primary
  | LPARENTHESIS arith_expression RPARENTHESIS
;

arith_primary ::=
            NUMBER
          | IDENTIFIER
;
